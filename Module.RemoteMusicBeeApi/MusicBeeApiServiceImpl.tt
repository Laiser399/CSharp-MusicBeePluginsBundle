<#@ template language="C#" #>
<#@ assembly name="$(SolutionDir)\Module.MusicBee.MetaInfo\bin\Debug\Module.MusicBee.MetaInfo.dll" #>
<#@ assembly name="$(SolutionDir)\Module.MusicBee.MetaInfo.Proto\bin\Debug\Module.MusicBee.MetaInfo.Proto.dll" #>
<#@ assembly name="$(SolutionDir)\Root\bin\Debug\Root.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Entities" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Extensions" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Helpers" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Proto.Extensions" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Proto.Services" #>
<#@ import namespace="Root.Extensions" #>
<#@ import namespace="Root.Helpers" #>
<#
    var methods = MetaInfoProvider.GetMethodsWithoutRestrictions();
    var namingService = new ProtoNamingService(
        "Empty",
        "_Request",
        "_Response");
#>
//-------------------------
// Autogenerated using t4 |
//-------------------------

using System;
using System.Linq;
using System.Threading.Tasks;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using Grpc.Core;
using Module.MusicBee.Autogen.Services.Abstract;
using Module.MusicBee.Enums;

// ReSharper disable ConstantNullCoalescingCondition

namespace Module.RemoteMusicBeeApi
{
    public sealed class MusicBeeApiServiceImpl : MusicBeeApiService.MusicBeeApiServiceBase
    {
        private readonly IBaseMusicBeeApi _mbApi;

        public MusicBeeApiServiceImpl(IBaseMusicBeeApi mbApi)
        {
            _mbApi = mbApi;
        }
<#
    foreach (var method in methods)
    {
        var responseMessageType = namingService.GetResponseMessageType(method);
        var requestMessageType = namingService.GetRequestMessageType(method);
        var argumentsPart = GetArgumentsPart(method);
#>

        public override Task<<#= responseMessageType #>> <#= method.Name #>(<#= requestMessageType #> request, ServerCallContext context)
        {
            return Task.Run(() =>
            {
<#
        if (method.HasReturnType())
        {
#>
                var result = _mbApi.<#= method.Name #>(<#= argumentsPart #>);
<#
        }
        else
        {
#>
                _mbApi.<#= method.Name #>(<#= argumentsPart #>);
<#
        }

        if (!method.HasAnyOutputParameters())
        {
#>
                return new <#= responseMessageType #>();
<#
        }
        else
        {
#>
                return new <#= responseMessageType #>()
                {
<#
            if (method.HasReturnType())
            {
                var responseAssignmentLine = GetResponseAssignmentLine(method.ReturnParameter, "result");
#>
                    <#= responseAssignmentLine #>
<#
            }

            foreach (var outputParameter in method.OutputParameters)
            {
                var responseAssignmentLine = GetResponseAssignmentLine(outputParameter);
#>
                    <#= responseAssignmentLine #>
<#
            }
#>
                };
<#
        }
#>
            });
        }
<#
    }
#>
        
    }
}
<#+
    private static string GetArgumentsPart(MethodDefinition method)
    {
        var inputArguments = method.InputParameters
            .Select(GetCallInputParameter);
        var outputArguments = method.OutputParameters
            .Select(x => $"out var {x.Name}");
        return string.Join(", ", inputArguments.Concat(outputArguments));
    }

    private static string GetCallInputParameter(ParameterDefinition parameter)
    {
        var castPrefix = parameter.Type.IsEnum
            ? $"({parameter.Type.Name})"
            : string.Empty;
        var castPostfix = GetCastPostfix(parameter);

        var toArrayPostfix = string.Empty;
        if (parameter.Type.IsEnumerable(out var elementType))
        {
            toArrayPostfix = elementType == typeof(byte)
                ? ".ToByteArray()"
                : ".ToArray()";
        }

        return $"{castPrefix}request.{parameter.Name.Capitalize()}{castPostfix}{toArrayPostfix}";
    }

    private static string GetCastPostfix(ParameterDefinition parameter)
    {
        if (parameter.Type.IsArray && parameter.Type.HasElementType)
        {
            var elementType = parameter.Type.GetElementType()!;
            if (elementType.IsEnum)
            {
                return $".Cast<{elementType.Name}>()";
            }
        }

        return string.Empty;
    }


    public string GetResponseAssignmentLine(ParameterDefinition parameter, string fieldName)
    {
        var rightPart = GetResponseAssignmentLineRightPart(
            parameter.Type,
            parameter.IsNullable,
            fieldName
            );
        return $"{fieldName.Capitalize()} = {rightPart},";
    }

    public string GetResponseAssignmentLine(ParameterDefinition parameter)
    {
        var rightPart = GetResponseAssignmentLineRightPart(
            parameter.Type,
            parameter.IsNullable,
            parameter.Name
            );
        return $"{parameter.Name.Capitalize()} = {rightPart},";
    }

    private static string GetResponseAssignmentLineRightPart(
        Type parameterType,
        bool isNullableType,
        string parameterName)
    {
        if (parameterType.IsEnumerable() && parameterType.HasElementType)
        {
            var elementType = parameterType.GetElementType();
            if (elementType is null)
            {
                throw new NotSupportedException("Could not generate code for enumerable without element type.");
            }

            var nullablePart = isNullableType
                ? $" ?? Array.Empty<{elementType.GetFixedName()}>()"
                : string.Empty;

            return elementType == typeof(byte)
                ? $"ByteString.CopyFrom({parameterName}{nullablePart})"
                : $"{{ {parameterName}{nullablePart} }}";
        }

        if (parameterType.IsEnum)
        {
            return $"(int){parameterName}";
        }

        return parameterName;
    }
#>