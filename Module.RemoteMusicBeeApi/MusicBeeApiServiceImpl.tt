<#@ template language="C#" #>
<#@ assembly name="$(SolutionDir)\Module.MusicBee.MetaInfo\bin\Debug\Module.MusicBee.MetaInfo.dll" #>
<#@ assembly name="$(SolutionDir)\Module.MusicBee.MetaInfo.Proto\bin\Debug\Module.MusicBee.MetaInfo.Proto.dll" #>
<#@ assembly name="$(SolutionDir)\Root\bin\Debug\Root.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Entities" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Extensions" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Helpers" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Proto.Extensions" #>
<#@ import namespace="Module.MusicBee.MetaInfo.Proto.Services" #>
<#@ import namespace="Root.Extensions" #>
<#@ import namespace="Root.Helpers" #>
//-------------------------
// Autogenerated using t4 |
//-------------------------

using System;
using System.Linq;
using System.Threading.Tasks;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using Grpc.Core;
using Module.MusicBee.Autogen.Services.Abstract;
using Module.MusicBee.Enums;

// ReSharper disable ConstantNullCoalescingCondition

namespace Module.RemoteMusicBeeApi
{
    public sealed class MusicBeeApiServiceImpl : MusicBeeApiService.MusicBeeApiServiceBase
    {
        private readonly IBaseMusicBeeApi _mbApi;

        public MusicBeeApiServiceImpl(IBaseMusicBeeApi mbApi)
        {
            _mbApi = mbApi;
        }
<#
    foreach (var method in _methods)
    {
        var responseMessageType = _namingService.GetResponseMessageType(method);
        var requestMessageType = _namingService.GetRequestMessageType(method);
        var arguments = GetMethodCallingArguments(method);
#>

        public override Task<<#= responseMessageType #>> <#= method.Name #>(<#= requestMessageType #> request, ServerCallContext context)
        {
            return Task.Run(() =>
            {
<#
        if (method.HasReturnType())
        {
#>
                var result = _mbApi.<#= method.Name #>(<#= arguments #>);
<#
        }
        else
        {
#>
                _mbApi.<#= method.Name #>(<#= arguments #>);
<#
        }

        if (!method.HasAnyOutputParameters())
        {
#>
                return new <#= responseMessageType #>();
<#
        }
        else
        {
#>
                return new <#= responseMessageType #>
                {
<#
            if (method.HasReturnType())
            {
                var value = GetResponseValue(method.ReturnParameter, "result");
#>
                    Result = <#= value #>,
<#
            }

            foreach (var outputParameter in method.OutputParameters)
            {
                var property = outputParameter.Name.Capitalize();
                var value = GetResponseValue(outputParameter);
#>
                    <#= property #> = <#= value #>,
<#
            }
#>
                };
<#
        }
#>
            });
        }
<#
    }
#>
    }
}
<#+
    private readonly IReadOnlyCollection<MethodDefinition> _methods =
        MetaInfoProvider.GetMethodsWithoutRestrictions();

    private readonly ProtoNamingService _namingService = new(
        "Empty",
        "_Request",
        "_Response");

    private static string GetMethodCallingArguments(MethodDefinition method)
    {
        var inputArguments = method.InputParameters
            .Select(GetCallingInputArgument);
        var outputArguments = method.OutputParameters
            .Select(x => $"out var {x.Name}");
        return string.Join(", ", inputArguments.Concat(outputArguments));
    }

    private static string GetCallingInputArgument(ParameterDefinition parameter)
    {
        var enumCast = parameter.Type.IsEnum
            ? $"({parameter.Type.Name})"
            : string.Empty;
        var propertyName = parameter.Name.Capitalize();
        var enumCastPostfix = GetEnumCastInCollection(parameter);
        var arrayCast = GetArrayCast(parameter);

        return $"{enumCast}request.{propertyName}{enumCastPostfix}{arrayCast}";
    }

    private static string GetEnumCastInCollection(ParameterDefinition parameter)
    {
        if (!parameter.Type.IsArray || !parameter.Type.HasElementType)
        {
            return string.Empty;
        }

        var elementType = parameter.Type.GetElementType()!;
        return elementType.IsEnum
            ? $".Cast<{elementType.Name}>()"
            : string.Empty;
    }

    private static string GetArrayCast(ParameterDefinition parameter)
    {
        if (!parameter.Type.IsEnumerable(out var elementType))
        {
            return string.Empty;
        }

        return elementType == typeof(byte)
            ? ".ToByteArray()"
            : ".ToArray()";
    }

    private static string GetResponseValue(ParameterDefinition parameter)
    {
        return GetResponseValue(parameter, parameter.Name);
    }

    private static string GetResponseValue(ParameterDefinition parameter, string parameterName)
    {
        if (parameter.Type.IsEnumerable() && parameter.Type.HasElementType)
        {
            var elementType = parameter.Type.GetElementType();
            if (elementType is null)
            {
                throw new NotSupportedException("Could not generate code for enumerable without element type.");
            }

            var nullablePart = parameter.IsNullable
                ? $" ?? Array.Empty<{elementType.GetFixedName()}>()"
                : string.Empty;

            return elementType == typeof(byte)
                ? $"ByteString.CopyFrom({parameterName}{nullablePart})"
                : $"{{ {parameterName}{nullablePart} }}";
        }

        return parameter.Type.IsEnum
            ? $"(int){parameterName}"
            : parameterName;
    }
#>